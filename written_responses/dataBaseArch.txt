The database architecture I have implemented is based on 4 different relational models(tables). The schema for the Players and Teams models were designed with the idea of being used mainly for identification and as Foreign Keys in other models. The Players model contains the player_id attribute of the BigInt data type and player_name attribute of the String data type. Similarly, the Teams model has the team_id and team_name attributes. Next the Games model contains four attributes: game_id of BigInt data type, date of DATE data type, and both a homeTeamID and awayTeamID, which are both Foreign Keys that are defined and connected to the team_id from the aforementioned Teams model. The playerGames is the final model in the database schema, and it holds all low-level statistical data such as points, assists, etc as Integer data types for individual players for a singular game. The playerGames model also makes references to two Foreign Keys, one connects it to the player_id from the Players model with which the data is related to, and another one connected to the game_id from the Games model denoting which game the player’s stats are from. Additionally, the model contains a unique “shots” column that holds JSON data regarding the individual shots taken by the player during, stored in a binary JSON form specific to PostgreSQL called jsonb. The reason for the separation of the Games model and the playerGames model was to make querying the database easier and more granular, especially when considering the eventual backend logic of the information by the Django API. In retrospect, if this was a real world project, I would have also created another table connecting players to their respective tables so that we would be able to know which player was a part of which team. But for the simplicity of designing with the deliverable in mind, I decided against it.  

